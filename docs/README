Raz Warman && Aviv Kotek


=============================
=      File description     =
=============================
SpaceShipFactory.java - implements the SpaceShipFactory class.
Action.java - implements the Action interface.
SpaceShip.java - implements the SpaceShip abstract class.
RunnerShip.java - implements the RunnerShip class.
HumanShip.java - implements the HumanShip class.
BasherShip.java - implements the BasherShip class.
AggressiveShip.java - implements the AggressiveShip class.
DrunkardShip.java - implements the DrunkardShip class.
SpecialShip.java - implements the SpecialShip class.
bubblesNoShield.gif - an image for the SpecialShip.
README - this file.


=============================
=          Design           =
=============================
The nine classes in this project maintain a relationship between them so that the user can simulate a
SpaceWars game between several spaceships (minimum two) that are divided to different types: Runner, Basher,
Human, Aggressive, Drunkard and Special.
The SpaceShip class is an abstract class that implements the Action interface, and is the common type of all
the spaceships (every other class is a spaceship in fact). The classes RunnerShip, HumanShip, BasherShip,
DrunkardShip, and SpecialShip all inherit from the SpaceShip class, and the AggressiveShip class inherits
from the BasherShip class.

The SpaceShip class has two abstract methods: getTurnValue and getAccelerationValue in order to verify
that the ship will in fact move every single round.
The implemented interface allows every inheriting spaceship type to override methods that are non obligatory
representing actions that each spaceship can preform. Those methods are doTeleport, doShield and doShoot
and are all void methods that are implemented as empty in the SpaceShip class, hence, if a spaceship type
wants to implement one of those operations, it simply needs to override that method and it will be performed
each round.

My design's advantages and disadvantages:

-In terms of extensibility, all the tools needed to create a new spaceship type that will perform as
instructed are available and it is clear what has to be implemented in order for the spaceship to perform
properly (otherwise the code won't compile). In order to add a new functionality to a spaceship, it has
somewhat of a disadvantage because the functionality must appear in the doAction method in the SpaceShip
class, thus it needs to be added to the Action interface, and as an empty method in the SpaceShip class,
so it can't be added directly to the inheriting spaceship type class. Also, if say a we want to create a
new spaceship type with different default start values (such as health and energy) we will have to implement
setters for those fields in the SpaceShip class because currently that option does not exist for extending
spaceships.

-In terms of Modularity, the program divides into logically understandable components. The SpaceShip
class is the general spaceship - holds all the qualities and methods that are common to all spaceship types,
while the Action interface is the one that sets them apart with their different behaviors. it is very clear
that the SpaceShip class is the one all the other spaceship type classes rely on, and so the way they
interact is vivid through the API of the SpaceShip class and the Action interface.

–In terms of Intuitiveness and understandability it is understandable through the API that the Spaceship
class provides all the needed tools to operate a spaceship and it demands implementing two methods that
ensure the movement of the spaceship. Through the Action interface it is also clear what other
functionalities a spaceship type can choose to implement, and so the design is intuitive and gives a general
impression of what a spaceship holds without giving away too much of the "behind the scenes"-meaning how
actually all the methods interact.

–In terms of representation and relationships the design makes sense because as said, every one of the
special type spaceships is a spaceship at its core, so each one is represented by a spaceship
and adds it's own qualities to it. Now because there are certain demands of each spaceship (moving and
regenerating for example) and a certain order of actions, it made sense to create a "general" structure
of methods (obligatory and non-obligatory) using abstract methods and the Interface, and each type of
spaceship will implement what is needed.

In addition, In the SpaceShipFactory class, the polymorphism principle comes to play as the returned array
is of type SpaceShip but contains actually the different types of spaceships that will play in the game,
and so the relationships that the spaceships share with the SpaceShip class allow it.

The behavior of the drunkard ship and special ship:

-Drunkard: I've stored all the possible turn values at a static final array and there is another static
final number that represents a maximal range for a random number. In addition, there are three fields,
one that represents the current turn direction, one that is a random number between zero and the maximal
range and another one is a counter that serves the class in the following form: the counter goes from
zero to the randomly picked number field and progresses by one each round. The spaceship will move in the
randomly picked direction only until the counter reaches the randomly picked number. When the counter
exceeds that amount, a new random number and direction are picked, and the process goes all over again.
The firing, teleport and shield operation are also random, and are picked in a function that creates
each time a random number from zero to the max random range constant. If that random number is smaller than
the randomly picked number field, the method will return true, otherwise false.

-Special: The Special ship is a defender: it attempts to defend the closest ship to it by trying to circle
it and fire around it all the time. One of the fields is a counter, and another is the current angle
between the ship and the nearest ship, the counter progresses by one each round and as long as it is
smaller than the degree amount, the ship will progress in a direction towards the nearest ship.



=============================
=  Implementation details   =
=============================
The main idea behind making the SpaceShip class abstract and implementing the Action interface in it
(instead of moving the necessary methods to the Interface and making all the spaceships implement the
interface), is that not all the spaceships implement the different functionalities (such as teleporting,
shields and shooting), so this way it saved me a lot of code duplication each time inserting an empty
method for each class that doesn't implement it-and instead I wrote it only once in the SpaceShip class
and each type can override it whenever.
Also, it is noticeable that the Aggressive type spaceship inherits from the Basher type spaceship. The
reason for that is saving code duplication since they both always accelerate and move towards the nearest
ship. So it was convenient to inherit from the Basher and override it's doShield method as empty and
implementing the doShoot method.
